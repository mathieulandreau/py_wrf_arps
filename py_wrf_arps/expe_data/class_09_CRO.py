import sys

from .class_expe import Expe
from .LidarScanModule2 import LidarScan2
from ..lib import manage_projection, manage_time, manage_angle, manage_path
from ..post import manage_LLJ

import numpy as np
import netCDF4
import datetime
import os
import copy

CRO_VARNAMES = {
    "LLJ_MH" : "llj_speed",
    "LLJ_WD" : "llj_direction",
    "LLJ_Z" : "llj_height",
}
class CRO(Expe):
    """
    Important note : In nc files (generated by Alexandra), the date associated to a 10 minute averaged value corresponds to the beginning of the 10 minute period 
    e.g. the velocity at 10:30 is averaged between 10:30 and 10:40. In WRF, the opposite is done because the file is output at the end of the averaging period. Thus,
    the self.date_list in the CRO object is shifted by 10 minutes to match the WRF definition.
    """
    
    code = "CRO"
    def __init__(self):
        super().__init__()
        
    def get_output_filenames(self):
        folder_list = manage_path.CRO_folder_list
        for folder in folder_list :
            if os.path.exists(folder + 'linreg052020.nc') :
                self.folder = folder
        self.filename = self.folder + 'linreg052020.nc'
    
        self.postprocdir = self.folder + "post/"
        if not os.path.exists(self.postprocdir):
            print('Create postproc directory in {0}'.format(self.postprocdir))
            os.makedirs(self.postprocdir, exist_ok=True)
        self.postproc_filename = self.postprocdir + 'CRO_post_052020.nc'
        
    def get_other_params(self):
        self.obj = LidarScan2(self.filename, era=False)
        self.dataframe = self.obj.wind_speed
        self.llj = self.obj.llj
        # height
        self.Z_vec = np.array(self.obj.heights)
        self.NZ = len(self.Z_vec)
        self.DZ_ZSTAG = np.diff(self.Z_vec)
        self.DZ = np.zeros(self.Z_vec.shape)
        self.DZ[1:-1] = (self.Z_vec[2:] - self.Z_vec[:-2])/2
        self.DZ[0] = self.Z_vec[1] - self.Z_vec[0]
        self.DZ[-1] = self.Z_vec[-1] - self.Z_vec[-2]
        # Time
        self.date_list = np.array(manage_time.to_datetime(self.dataframe.index)) + manage_time.to_timedelta("10m")
        self.llj_date_list = np.array(manage_time.to_datetime(self.llj.index)) + manage_time.to_timedelta("10m")
        self.llj_time_slice = manage_time.get_time_slice(self.llj_date_list, self.date_list)
        self.NT = len(self.date_list)
        self.DT = self.date_list[1] - self.date_list[0]
        self.max_time_correction = manage_time.to_datetime64(self.date_list[1]) - manage_time.to_datetime64(self.date_list[0])
        # Horizontal
        self.range_max = 3000
        self.azimuth_min = 159
        self.azimuth_max = 201
        self.lat_lidar, self.lon_lidar = 47.2857, -2.517058
        if os.path.exists(self.postproc_filename) :
            with netCDF4.Dataset(self.postproc_filename, "r") as file :
                self.post_variables = file.variables.keys()
    
    def get_data(self, varname, itime="ALL_TIMES", time_slice=None, crop=None, saved=None, **kwargs):
        if saved is None : saved = {}
        if varname in saved : return np.squeeze(saved[varname])
        if time_slice is None :
            time_slice = manage_time.get_time_slice(itime, self.date_list)
        if crop is not None :
            if type(crop) is int :
                z_slice = crop
            elif type(crop) is tuple :
                if type(crop[0]) in [int, slice, np.int64] :
                    z_slice = crop[0]
                elif type(crop[0]) is list :
                    z_slice = slice(crop[0][0], crop[0][1]+1)
                else :
                    z_slice = slice(self.NZ)
            else :
                z_slice = slice(self.NZ)
        else :
            z_slice = slice(self.NZ)
        
        if varname.upper() == "IT" :
            data = np.arange(5000, dtype="int")[kwargs["time_slice"]]
        elif varname.upper() == "IZ" :
            data = np.arange(self.NZ, dtype="int")[z_slice]
        elif varname == "MH":
            data = np.squeeze(np.array(self.obj.wind_speed)[time_slice, z_slice])
        elif varname == "WD":
            data = np.squeeze(np.array(self.obj.wind_direction)[time_slice, z_slice])
        elif varname == "TIME":
            data = np.array(self.date_list[time_slice])
        elif varname in ["Z", "ZP"] :
            data = self.Z_vec[z_slice]
        elif varname in ["DZ"] :
            data = self.DZ[z_slice]
        elif varname in self.post_variables :
            ## hard-coded, can do better
            with netCDF4.Dataset(self.postproc_filename, "r") as file :
                var = file[varname][:]
                if var.ndim == 2 :
                    return var[time_slice, z_slice]
                elif var.ndim == 1 :
                    if len(var) == self.NT :
                        return var[time_slice]
                    elif len(var) == self.NZ :
                        return var[z_slice]
                return var
        # elif varname in CRO_VARNAMES :
        #     varname_cro = CRO_VARNAMES[varname]
        #     if varname_cro.startswith("llj_"):
        #         # the llj dataframe contains only dates at which an llj was detected so we fill with nans when there are no LLJ
        #         var = np.zeros(len(self.date_list))*np.nan
        #         var[self.llj_time_slice] = np.array(self.obj.llj[varname_cro[4:]])
        #         return var[time_slice]
        elif varname.startswith("llj_") and varname[4:] in self.obj.llj :
            var = np.zeros(len(self.date_list))*np.nan
            var[self.llj_time_slice] = np.array(self.obj.llj[varname[4:]])
            return var[time_slice]
        else :
            data = self.calculate(varname, itime=itime, time_slice=time_slice, crop=crop, saved=saved, **kwargs)
        saved[varname] = data
        return data
       
    def calculate(self, varname, **kwargs) :
        if varname.startswith("U_AD"):
            #like U_AD50, U_AD220 : rotation of U and V with an angle of angle_deg ° from North
            # NOTE : U_AD270 = U, V_AD270 = V = U_AD180
            if varname.startswith("U_AD") : angle_deg = int(varname[4:])
            MH = self.get_data("MH", **kwargs)
            WD = self.get_data("WD", **kwargs)
            return MH*np.cos(np.deg2rad(angle_deg - WD))
        elif varname.startswith("V_AD") :
            #like V_AD50, V_AD220 : rotation of U and V with an angle of angle_deg ° from North
            # NOTE : U_AD270 = U, V_AD270 = V
            if varname.startswith("V_AD") : angle_deg = int(varname[4:])
            MH = self.get_data("MH", **kwargs)
            WD = self.get_data("WD", **kwargs)
            return MH*np.sin(np.deg2rad(angle_deg - WD))
        elif varname == "U" :
            return self.get_data("U_AD270", **kwargs)
        elif varname == "V" :
            return self.get_data("V_AD270", **kwargs)
        elif varname in ["WD180", "LLJ_WD180"]: #Wind direction in degrees [-180, 180]
            WD = self.get_data(varname[:-3], **kwargs)
            return manage_angle.angle180(WD)
        elif varname.startswith("WD18021"): #Wind direction in degrees [-180, 180]
            WD = self.get_data("WD"+varname[5:], **kwargs)
            return manage_angle.angle180(WD)
        elif varname in ["LLJ", "LLJ_IZ", "LLJ_Z", "LLJ_MH", "LLJ_PROM", "LLJ_WIDTH"] :
            new_kwargs = copy.deepcopy(kwargs)
            new_kwargs["crop"] = ("ALL", "ALL", "ALL")
            new_kwargs["saved"] = {}
            MH = self.get_data("MH", **new_kwargs)
            Z = self.get_data("Z", **new_kwargs)
            IZ = self.get_data("IZ", **new_kwargs)
            DZ = self.get_data("DZ", **new_kwargs)
            zaxis = 0
            if MH.ndim == 2 :
                NT, NZ = MH.shape
                Z = np.array([Z]*NT)
                DZ = np.array([DZ]*NT)
                zaxis = 1
            print(MH.shape, Z.shape, IZ.shape, DZ.shape, zaxis)
            p = kwargs["saved"]
            p["LLJ"], p["LLJ_IZ"], p["LLJ_Z"], p["LLJ_MH"], p["LLJ_PROM"], p["LLJ_WIDTH"] = manage_LLJ.detect_LLJ(MH, Z, IZ, DZ, zaxis, max_height=500, prom_abs=2, prom_rel=0.2, width=50, squeeze=False)
            return np.squeeze(p[varname])
        elif varname.startswith("LLJ_"):
            return self.calculate_LLJ(varname, **kwargs)
        else :
            raise(Exception("error in class_09_CRO.get_data, the variable name : " + str(varname) + " doesn't exist"))
            
    def calculate_LLJ(self, varname, **kwargs):
        if varname in ["LLJ_MIN"]:
            return self.get_data("LLJ_MH", **kwargs) - self.get_data("LLJ_PROM", **kwargs)
        elif varname.startswith("LLJ_"):
            varname1 = varname[4:]
            LLJ_IZ = self.get_data("LLJ_IZ", **kwargs)
            LLJ = self.get_data("LLJ", **kwargs)
            new_kwargs = copy.deepcopy(kwargs)
            new_kwargs["crop"] =  ("ALL", kwargs["crop"][1], kwargs["crop"][2])
            new_kwargs["saved"] = {}
            var1 = self.get_data(varname1, **new_kwargs)
            zaxis = var1.ndim-1
            LLJ = np.expand_dims(LLJ, axis=zaxis).astype(int)
            LLJ_IZ = np.expand_dims(LLJ_IZ, axis=zaxis).astype(int)
            LLJ_IZ[LLJ!=1] = 0
            print(var1.shape, LLJ.shape, LLJ_IZ.shape)
            var = np.take_along_axis(var1, LLJ_IZ, axis=zaxis)
            var[LLJ!=1] = np.nan
            return var
        else :
            raise(Exception(f"Unknown varname {varname} in CRO.calculate_GW"))
    
    def get_label(self) :
        return "Croisic LiDAR"
    
    def get_ZT(self, itime="ALL_TIMES", crop=None, **kwargs):
        t_vec = manage_time.get_date_list(self.date_list, itime=itime, max_time_correction=self.max_time_correction)
        Z, t = np.meshgrid(self.Z_vec, t_vec) 
        return Z, t, self.Z_vec, t_vec
    
    def get_limits(self) :
        xl, yl = manage_projection.ll_to_xy(self.lon_lidar, self.lat_lidar, manage_projection.CRS)
        xc1 = xl + self.range_max * np.sin(self.azimuth_min)
        yc1 = yl + self.range_max * np.cos(self.azimuth_min)
        xc2 = xl + self.range_max * np.sin(self.azimuth_max)
        yc2 = yl + self.range_max * np.cos(self.azimuth_max)
        lon1, lat1 = manage_projection.xy_to_ll(xc1, yc1, manage_projection.CRS)
        lon2, lat2 = manage_projection.xy_to_ll(xc2, yc2, manage_projection.CRS)
        print(np.array([lon1, self.lon_lidar, lon2]), np.array([lat1, self.lat_lidar, lat2]))
        return np.array([lon1, self.lon_lidar, lon2]), np.array([lat1, self.lat_lidar, lat2])
        
    def write_postproc(self, varname, var, dims, long_name="", standard_name="", units="", latex_units="", typ=np.float32) :
        """
        Description
            Write a variable in the postproc datafile
        Parameters
            varname : str : name of the variable, ex : "X", "LAT", "U_XSTAG"
            var : np.array : data
            dims : tuple of str : dimensions of the variable ; ex : ("x"), ("y", "x"), (,)
        Optional
            itime : int : index of the date in self.date_list ; ex : 0, 2, -1 ; default : 0
            long_name : str : long name of the variable ; ex : "South-West coordinate" ; default : ""
            standard_name : str : standard name of the variable ; ex : "X coordinate" ; default : ""
            units : str : units name ; ex : "m", "Pa.s-1" ; default : ""
            latex_units : str : units in latex format ; ex : "m", "Pa.s^{-1}" ; default : ""
        Returns 
            Dom 
        """
        filename = self.postproc_filename
        if standard_name == "" :
            standard_name = long_name 
        if long_name == "" :
            long_name = standard_name
            
        if not os.path.exists(filename):
            print("creating postproc file : ", filename)
            init = True
            ncfout = netCDF4.Dataset(filename, mode="w", format='NETCDF4_CLASSIC')
        else :
            print("opening file : ", filename)
            init = False
            ncfout = netCDF4.Dataset(filename, mode="a", format='NETCDF4_CLASSIC')
        if init :
            ncfout.Title        = "py_wrf_arps postproc"
            ncfout.Institution  = "LHEEA-DAUC"
            ncfout.FMTVER       = "NetCDF 4.0 Classic"
            ncfout.Source       = "py_wrf_arps/expe_data/class_09_CRO.py"
            ncfout.References   = "See class_09_CRO.py"
            ncfout.Comment      = "Postproc data saved in file"
            now = datetime.datetime.now()
            dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
            ncfout.History      = "Creation date: {date}".format(date=dt_string)
            ncfout.createDimension('time', self.NT)
            ncfout.createDimension('height', self.NZ)
            
        if varname in ncfout.variables :
            if debug : print("opening with r+")
            ncfout.close()
            ncfout = netCDF4.Dataset(filename, mode="r+", format='NETCDF4_CLASSIC')
            ncout = ncfout[varname]
        else :
            ncout = ncfout.createVariable(varname, typ, dims)
        ncout.long_name = long_name
        ncout.standard_name = standard_name
        ncout.units = units
        ncout.latex_units = latex_units
        ncout.stagger = ""
        ncout[:] = var[:]
        if debug : print(np.min(var[:]), np.max(var[:]))
        if debug : print(np.min(ncout[:]), np.max(ncout[:]))
        ncfout.close()