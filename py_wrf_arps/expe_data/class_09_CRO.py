import sys

from .class_expe import Expe
from .LidarScanModule2 import LidarScan2
from ..lib import manage_projection, manage_time, manage_angle, manage_path

import numpy as np
import netCDF4
import datetime
import os

class CRO(Expe):
    """
    Important note : In nc files (generated by Alexandra), the date associated to a 10 minute averaged value corresponds to the beginning of the 10 minute period 
    e.g. the velocity at 10:30 is averaged between 10:30 and 10:40. In WRF, the opposite is done because the file is output at the end of the averaging period. Thus,
    the self.date_list in the CRO object is shifted by 10 minutes to match the WRF definition.
    """
    
    code = "CRO"
    def __init__(self):
        super().__init__()
        
    def get_output_filenames(self):
        folder_list = manage_path.CRO_folder_list
        for folder in folder_list :
            if os.path.exists(folder + 'linreg052020.nc') :
                self.folder = folder
        self.filename = self.folder + 'linreg052020.nc'
    
        self.postprocdir = self.folder + "post/"
        if not os.path.exists(self.postprocdir):
            print('Create postproc directory in {0}'.format(self.postprocdir))
            os.makedirs(self.postprocdir, exist_ok=True)
        self.postproc_filename = self.postprocdir + 'CRO_post_052020.nc'
        
    def get_other_params(self):
        self.obj = LidarScan2(self.filename, era=False)
        self.dataframe = self.obj.wind_speed
        self.Z_vec = self.obj.heights
        self.NZ = len(self.Z_vec)
        self.date_list = np.array(manage_time.to_datetime(self.dataframe.index)) + manage_time.to_timedelta("10m")
        self.NT = len(self.date_list)
        self.DT = self.date_list[1] - self.date_list[0]
        self.max_time_correction = manage_time.to_datetime64(self.date_list[1]) - manage_time.to_datetime64(self.date_list[0])
        self.range_max = 3000
        self.azimuth_min = 159
        self.azimuth_max = 201
        self.lat_lidar, self.lon_lidar = 47.2857, -2.517058
        if os.path.exists(self.postproc_filename) :
            with netCDF4.Dataset(self.postproc_filename, "r") as file :
                self.post_variables = file.variables.keys()
    
    def get_data(self, varname, itime="ALL_TIMES", time_slice=None, crop=None, **kwargs):
        if time_slice is None :
            time_slice = manage_time.get_time_slice(itime, self.date_list)
        if crop is not None :
            if type(crop) is int :
                z_slice = crop
            elif type(crop) is tuple :
                if type(crop[0]) in [int, slice, np.int64] :
                    z_slice = crop[0]
                elif type(crop[0]) is list :
                    z_slice = slice(crop[0][0], crop[0][1]+1)
                else :
                    z_slice = slice(self.NZ+1)
            else :
                z_slice = slice(self.NZ+1)
        else :
            z_slice = slice(self.NZ+1)
        if varname == "MH":
            return np.squeeze(np.array(self.obj.wind_speed)[time_slice, z_slice])
        elif varname == "WD":
            return np.squeeze(np.array(self.obj.wind_direction)[time_slice, z_slice])
        elif varname == "TIME":
            return np.array(self.date_list[time_slice])
        elif varname in ["Z", "ZP"] :
            return self.Z_vec[z_slice]
        elif varname in self.post_variables :
            ## hard-coded, can do better
            with netCDF4.Dataset(self.postproc_filename, "r") as file :
                var = file[varname][:]
                if var.ndim == 2 :
                    return var[time_slice, z_slice]
                elif var.ndim == 1 :
                    if len(var) == self.NT :
                        return var[time_slice]
                    elif len(var) == self.NZ :
                        return var[z_slice]
                return var
        else :
            return self.calculate(varname, itime=itime, time_slice=time_slice, crop=crop, **kwargs)
       
    def calculate(self, varname, **kwargs) :
        if varname.startswith("U_AD"):
            #like U_AD50, U_AD220 : rotation of U and V with an angle of angle_deg ° from North
            # NOTE : U_AD270 = U, V_AD270 = V = U_AD180
            if varname.startswith("U_AD") : angle_deg = int(varname[4:])
            MH = self.get_data("MH", **kwargs)
            WD = self.get_data("WD", **kwargs)
            return MH*np.cos(np.deg2rad(angle_deg - WD))
        elif varname.startswith("V_AD") :
            #like V_AD50, V_AD220 : rotation of U and V with an angle of angle_deg ° from North
            # NOTE : U_AD270 = U, V_AD270 = V
            if varname.startswith("V_AD") : angle_deg = int(varname[4:])
            MH = self.get_data("MH", **kwargs)
            WD = self.get_data("WD", **kwargs)
            return MH*np.sin(np.deg2rad(angle_deg - WD))
        elif varname == "U" :
            return self.get_data("U_AD270", **kwargs)
        elif varname == "V" :
            return self.get_data("V_AD270", **kwargs)
        elif varname in ["WD180"]: #Wind direction in degrees [-180, 180]
            WD = self.get_data(varname[:-3], **kwargs)
            return manage_angle.angle180(WD)
        elif varname.startswith("WD18021"): #Wind direction in degrees [-180, 180]
            WD = self.get_data("WD"+varname[5:], **kwargs)
            return manage_angle.angle180(WD)
        else :
            raise(Exception("error in class_09_CRO.get_data, the variable name : " + str(varname) + " doesn't exist"))
    
    def get_label(self) :
        return "Croisic LiDAR"
    
    def get_ZT(self, itime="ALL_TIMES", crop=None, **kwargs):
        t_vec = manage_time.get_date_list(self.date_list, itime=itime, max_time_correction=self.max_time_correction)
        Z, t = np.meshgrid(self.Z_vec, t_vec) 
        return Z, t, self.Z_vec, t_vec
    
    def get_limits(self) :
        xl, yl = manage_projection.ll_to_xy(self.lon_lidar, self.lat_lidar, manage_projection.CRS)
        xc1 = xl + self.range_max * np.sin(self.azimuth_min)
        yc1 = yl + self.range_max * np.cos(self.azimuth_min)
        xc2 = xl + self.range_max * np.sin(self.azimuth_max)
        yc2 = yl + self.range_max * np.cos(self.azimuth_max)
        lon1, lat1 = manage_projection.xy_to_ll(xc1, yc1, manage_projection.CRS)
        lon2, lat2 = manage_projection.xy_to_ll(xc2, yc2, manage_projection.CRS)
        print(np.array([lon1, self.lon_lidar, lon2]), np.array([lat1, self.lat_lidar, lat2]))
        return np.array([lon1, self.lon_lidar, lon2]), np.array([lat1, self.lat_lidar, lat2])
        

        
    def write_postproc(self, varname, var, dims, long_name="", standard_name="", units="", latex_units="", typ=np.float32) :
        """
        Description
            Write a variable in the postproc datafile
        Parameters
            varname : str : name of the variable, ex : "X", "LAT", "U_XSTAG"
            var : np.array : data
            dims : tuple of str : dimensions of the variable ; ex : ("x"), ("y", "x"), (,)
        Optional
            itime : int : index of the date in self.date_list ; ex : 0, 2, -1 ; default : 0
            long_name : str : long name of the variable ; ex : "South-West coordinate" ; default : ""
            standard_name : str : standard name of the variable ; ex : "X coordinate" ; default : ""
            units : str : units name ; ex : "m", "Pa.s-1" ; default : ""
            latex_units : str : units in latex format ; ex : "m", "Pa.s^{-1}" ; default : ""
        Returns 
            Dom 
        """
        filename = self.postproc_filename
        if standard_name == "" :
            standard_name = long_name 
        if long_name == "" :
            long_name = standard_name
            
        if not os.path.exists(filename):
            print("creating postproc file : ", filename)
            init = True
            ncfout = netCDF4.Dataset(filename, mode="w", format='NETCDF4_CLASSIC')
        else :
            print("opening file : ", filename)
            init = False
            ncfout = netCDF4.Dataset(filename, mode="a", format='NETCDF4_CLASSIC')
        if init :
            ncfout.Title        = "py_wrf_arps postproc"
            ncfout.Institution  = "LHEEA-DAUC"
            ncfout.FMTVER       = "NetCDF 4.0 Classic"
            ncfout.Source       = "py_wrf_arps/expe_data/class_09_CRO.py"
            ncfout.References   = "See class_09_CRO.py"
            ncfout.Comment      = "Postproc data saved in file"
            now = datetime.datetime.now()
            dt_string = now.strftime("%Y-%m-%d %H:%M:%S")
            ncfout.History      = "Creation date: {date}".format(date=dt_string)
            ncfout.createDimension('time', self.NT)
            ncfout.createDimension('height', self.NZ)
            
        if varname in ncfout.variables :
            if debug : print("opening with r+")
            ncfout.close()
            ncfout = netCDF4.Dataset(filename, mode="r+", format='NETCDF4_CLASSIC')
            ncout = ncfout[varname]
        else :
            ncout = ncfout.createVariable(varname, typ, dims)
        ncout.long_name = long_name
        ncout.standard_name = standard_name
        ncout.units = units
        ncout.latex_units = latex_units
        ncout.stagger = ""
        ncout[:] = var[:]
        if debug : print(np.min(var[:]), np.max(var[:]))
        if debug : print(np.min(ncout[:]), np.max(ncout[:]))
        ncfout.close()